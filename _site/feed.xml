<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-03T11:10:55+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinlu Zhang</title><subtitle>My Website with Blogs, Publications, Projects and Resume...&gt;</subtitle><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><entry><title type="html">Human Pose综述</title><link href="http://localhost:4000/2020/04/03/human-pose-review.html" rel="alternate" type="text/html" title="Human Pose综述" /><published>2020-04-03T00:00:00+08:00</published><updated>2020-04-03T00:00:00+08:00</updated><id>http://localhost:4000/2020/04/03/human-pose-review</id><content type="html" xml:base="http://localhost:4000/2020/04/03/human-pose-review.html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/20200321094012.png&quot; alt=&quot;20200321094012&quot; style=&quot;zoom: 80%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出这四个部分都是与人体姿态有关的，也是姿态估计的具体分支&lt;/p&gt;

&lt;h2 id=&quot;姿态识别&quot;&gt;姿态识别&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;姿态识别一般流程如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://jinluzhang.site/PublicPic/Pic/20200320172220.png&quot; alt=&quot;20200320172220&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出人体分割与人体姿态识别是姿态识别大类的两个关键步骤，人体分割是人体姿态识别（动作识别、身份识别等）的基础。&lt;/p&gt;

&lt;h3 id=&quot;人体分割-人体骨骼关键点检测skeleton&quot;&gt;人体分割-人体骨骼关键点检测（skeleton）&lt;/h3&gt;

&lt;p&gt;人体分割使用的方法可以大体分为人体骨骼关键点检测、语义分割等方式实现。人体骨骼关键点检测输出是人体的骨架信息，一般主要作为&lt;strong&gt;人体姿态识别的基础部分&lt;/strong&gt;，主要用于分割、对齐等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/20200321094432.png&quot; alt=&quot;20200321094432&quot; /&gt;&lt;/p&gt;

&lt;p&gt;人体骨骼关键点检测是一种多方面任务，包含了目标检测、人体骨骼关键点检测、分割等。&lt;/p&gt;

&lt;p&gt;人体骨骼关键点检测可以分为二维（2D）和三维（3D）的人体骨骼关键点检测；&lt;/p&gt;

&lt;p&gt;按照检测的方法又能分为自底向上、自顶向下两个方式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;人体骨骼关键点检测的挑战：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;每张图片中包含人的数量是未知的，图像中人越多，计算复杂度越大（计算量与人的数量正相关），这使得处理时间变长，从而使&lt;strong&gt;real time&lt;/strong&gt;变得困难。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;人与人之间会存在如&lt;strong&gt;接触、遮挡&lt;/strong&gt;等关系，导致将不同人的关键节点区分出来的难度增加，有可能会将骨骼关键点误认为是另一个人的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;关键点区域的图像信息比较难区分&lt;/strong&gt;，也就是说某个关键点检测时容易出现检测位置不准或者置信度不准，甚至将背景的图像当成关键点图像的错误。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;人体不同关键点检测的难易程度是不一样的，对于腰部、腿部这类没有比较明显特征关键点的检测要难于头部附近关键点的检测，&lt;strong&gt;需要对不同的关键点区别对待&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;2d人体骨骼关键点检测实现&quot;&gt;&lt;strong&gt;2D人体骨骼关键点检测实现&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/image-20200321115712607-1584763108036.png&quot; alt=&quot;image-20200321115712607&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/640.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:90%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代表作：&lt;/p&gt;

&lt;p&gt;自顶向下：RMPE （AlphaPose） https://arxiv.org/abs/1612.00137v3&lt;/p&gt;

&lt;p&gt;自底向上：PAFs（OpenPose） https://arxiv.org/abs/1611.08050&lt;/p&gt;

&lt;h4 id=&quot;2d人体骨骼关键点检测实现-1&quot;&gt;&lt;strong&gt;2D+人体骨骼关键点检测实现&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;实质是：2D图像+3D重建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2D+人体骨骼关键点检测多使用3D重建的方法，一般输入都是RGB的2D图像数据，首先使用2D人体骨骼关键点检测的方法检测出2D的人体骨骼关键点后，再使用3D重建的方式，将2D的关键点信息转到3D的空间中，输出的就是3维人体骨骼关键点信息。这种方法使用的图像数据不是真的3D数据，&lt;strong&gt;输出的3维的信息主要是通过2D到3D重建的方式实现的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;2D+人体骨骼关键点检测输出的人体骨骼关键点信息是3D数据，即每个关节都是一个3D坐标（x,y,z）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/640-1584764809340.webp&quot; alt=&quot;img&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代表作：DensePose https://arxiv.org/abs/1802.00434&lt;/p&gt;

&lt;h4 id=&quot;3d人体骨骼关键点检测&quot;&gt;&lt;strong&gt;3D人体骨骼关键点检测：&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;根据输入图像数据是RGB还是RGBD可分为2D+人体骨骼关键点检测、3D人体骨骼关键点检测。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/image-20200321115912509.png&quot; alt=&quot;image-20200321115912509&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入的图像数据：RGBD（3D）&lt;/p&gt;

&lt;p&gt;Depth Image实际上也是一幅真实的3D图像数据，Depth Image包含了深度信息、图像的高宽信息。CNN+RNN是目前的主流方法。&lt;/p&gt;

&lt;h3 id=&quot;人体姿态识别&quot;&gt;人体姿态识别&lt;/h3&gt;

&lt;p&gt;人体姿态识别包括动作识别、身份识别两个方面，关键在人体特征提取，人体特征提取主要完成动作特征提取、身份特征提取。&lt;/p&gt;

&lt;h4 id=&quot;动作识别&quot;&gt;动作识别&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/20200320172906.png&quot; alt=&quot;20200320172906&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;身份识别&quot;&gt;身份识别&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/20200321094551.png&quot; alt=&quot;20200321094551&quot; /&gt;&lt;/p&gt;</content><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><category term="pose" /><category term="paper" /><summary type="html">可以看出这四个部分都是与人体姿态有关的，也是姿态估计的具体分支 姿态识别 姿态识别一般流程如下： 可以看出人体分割与人体姿态识别是姿态识别大类的两个关键步骤，人体分割是人体姿态识别（动作识别、身份识别等）的基础。 人体分割-人体骨骼关键点检测（skeleton） 人体分割使用的方法可以大体分为人体骨骼关键点检测、语义分割等方式实现。人体骨骼关键点检测输出是人体的骨架信息，一般主要作为人体姿态识别的基础部分，主要用于分割、对齐等。 人体骨骼关键点检测是一种多方面任务，包含了目标检测、人体骨骼关键点检测、分割等。 人体骨骼关键点检测可以分为二维（2D）和三维（3D）的人体骨骼关键点检测； 按照检测的方法又能分为自底向上、自顶向下两个方式 人体骨骼关键点检测的挑战： 每张图片中包含人的数量是未知的，图像中人越多，计算复杂度越大（计算量与人的数量正相关），这使得处理时间变长，从而使real time变得困难。 人与人之间会存在如接触、遮挡等关系，导致将不同人的关键节点区分出来的难度增加，有可能会将骨骼关键点误认为是另一个人的。 关键点区域的图像信息比较难区分，也就是说某个关键点检测时容易出现检测位置不准或者置信度不准，甚至将背景的图像当成关键点图像的错误。 人体不同关键点检测的难易程度是不一样的，对于腰部、腿部这类没有比较明显特征关键点的检测要难于头部附近关键点的检测，需要对不同的关键点区别对待。 2D人体骨骼关键点检测实现 代表作： 自顶向下：RMPE （AlphaPose） https://arxiv.org/abs/1612.00137v3 自底向上：PAFs（OpenPose） https://arxiv.org/abs/1611.08050 2D+人体骨骼关键点检测实现 实质是：2D图像+3D重建 2D+人体骨骼关键点检测多使用3D重建的方法，一般输入都是RGB的2D图像数据，首先使用2D人体骨骼关键点检测的方法检测出2D的人体骨骼关键点后，再使用3D重建的方式，将2D的关键点信息转到3D的空间中，输出的就是3维人体骨骼关键点信息。这种方法使用的图像数据不是真的3D数据，输出的3维的信息主要是通过2D到3D重建的方式实现的。 2D+人体骨骼关键点检测输出的人体骨骼关键点信息是3D数据，即每个关节都是一个3D坐标（x,y,z） 代表作：DensePose https://arxiv.org/abs/1802.00434 3D人体骨骼关键点检测： 根据输入图像数据是RGB还是RGBD可分为2D+人体骨骼关键点检测、3D人体骨骼关键点检测。 输入的图像数据：RGBD（3D） Depth Image实际上也是一幅真实的3D图像数据，Depth Image包含了深度信息、图像的高宽信息。CNN+RNN是目前的主流方法。 人体姿态识别 人体姿态识别包括动作识别、身份识别两个方面，关键在人体特征提取，人体特征提取主要完成动作特征提取、身份特征提取。 动作识别 身份识别</summary></entry><entry><title type="html">如何高效地进行文献阅读和总结？</title><link href="http://localhost:4000/2020/03/28/how-to-read-papers.html" rel="alternate" type="text/html" title="如何高效地进行文献阅读和总结？" /><published>2020-03-28T00:00:00+08:00</published><updated>2020-03-28T00:00:00+08:00</updated><id>http://localhost:4000/2020/03/28/how-to-read-papers</id><content type="html" xml:base="http://localhost:4000/2020/03/28/how-to-read-papers.html">&lt;!--more--&gt;
&lt;p&gt;&lt;em&gt;最近这段时间看论文看到的头疼，相信很多第一次忙毕业论文或者研究课题的同学都深有体会，我总结一些自己阅读文献的经验和总结方法，不足之处还请多多指教。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;为什么进行文献阅读&quot;&gt;为什么进行文献阅读？&lt;/h2&gt;

&lt;p&gt;知乎一个回答让我觉得很有意思，原文如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不断涌现的论文，其实就是学术界的升级安装包。你不断读论文，就是为了跟学术共同体&lt;strong&gt;保持同步&lt;/strong&gt;。但是，只有你跟这篇论文所&lt;strong&gt;依赖&lt;/strong&gt;的那些基础知识同步以后，安装这个升级包才有意义，也才能水到渠成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人认为，论文就是研究者的presentation，能够以最严谨、简洁、客观（仅限于高水平文献）展示自己的idea，读最新的文献是为了掌握最新的学术动态，读经典文献是为了对领域的发展和基础有更深的了解。所有的论文都要站在前人的肩膀上再进一步，凭空捏造一个全新的成果不可靠，也不现实，所以读文献，是所有研究者必经之路。&lt;/p&gt;

&lt;h2 id=&quot;如何选择文献&quot;&gt;如何选择文献&lt;/h2&gt;

&lt;p&gt;关于文献的搜索和整理以及相关工具的使用，有时间我会单独写一篇笔记，这里着重介绍一些大佬还有我个人如何进行选择文献和筛选的。&lt;/p&gt;

&lt;h3 id=&quot;1-通过综述入门&quot;&gt;1. 通过综述入门&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;原则：读综述以读全为目的，1-2篇足矣&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多人推荐直接阅读最新的文献，我认为如果有充足的时间，可以先读该领域的综述，最好是最近三年的综述，可以更好地认识该领域：包括经典方法、最新的热点、研究趋势、技术难点等，读文献综述可以知道&lt;strong&gt;已经做出了什么成果，还需要做什么事情，哪些问题没有解决&lt;/strong&gt;。综述多为该领域的资深人士编写，视角更宽广，可以提高可言的视野和思路，读一两篇综述，就可以对该领域有个大致了解。查找方法可以直接通过&lt;a href=&quot;https://scholar.google.com/&quot;&gt;Google Scholor&lt;/a&gt;或者&lt;a href=&quot;webofknowledge.com&quot;&gt;Web of Science&lt;/a&gt;上进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Survey/Review+&amp;lt;领域&amp;gt;&lt;/code&gt;的检索。(免费用学校购买的版权看paper真的是爽:satisfied:)&lt;/p&gt;

&lt;h3 id=&quot;2-定位细分领域与相关文献&quot;&gt;2. 定位细分领域与相关文献&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;原则：读新、读典&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最新的好论文才能代表最近的研究趋势和研究热点，入门阶段不宜不要过多沉溺于十年前的作品（经典除外）&lt;/p&gt;

&lt;p&gt;通过综述锁定自己想做的某一个细分问题，以姿态估计为例，包括skeleton检测、动作识别、2D pose、3D pose、2D+ Pose等细分领域，确定该细分领域后，可以先通过综述中提到的reference下手，把他们先找全，往往这些方法都是SOTA或者经典方法，再根据他们论文中提到的文献，进行筛选、汇总。这部分工作一般需要先阅读一部分论文，才能有分辨能力的进一步筛选文献。&lt;/p&gt;

&lt;p&gt;还有一种方法，可以直接找到领域内顶级期刊、会议的整理，直接筛选最近两三年的相关领域论文，这种方法比较费力，但是可以很快速的阅读到最新的论文。&lt;/p&gt;

&lt;p&gt;一般筛选25-40篇就可以开始系统地阅读了，不要只忙于筛选搜集而后束之高阁，那样毫无意义。&lt;/p&gt;

&lt;h3 id=&quot;3读人读组&quot;&gt;3.读人，读组&lt;/h3&gt;

&lt;p&gt;这个是建立在对该领域有一定了解的基础上，读得多了，参加的讨论多了，自然就知道该领域哪些大佬，哪些group有杰出的工作。可以谷歌他们的个人网站或者通过Google scholar搜索大佬的作品，挑选着读。&lt;/p&gt;

&lt;h2 id=&quot;如何阅读&quot;&gt;如何阅读&lt;/h2&gt;

&lt;h3 id=&quot;文献文章结构&quot;&gt;文献文章结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/image-20200328174957659.png&quot; alt=&quot;image-20200328174957659&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般来说文章的大体结构是如上所示，有了结构才有读论文的节奏和思路&lt;/p&gt;

&lt;h3 id=&quot;阅读顺序&quot;&gt;阅读顺序&lt;/h3&gt;

&lt;p&gt;我读论文的顺序大体如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先看摘要（abstract），摘要可以概括一篇文章的主题和基本内容，许多文章只看摘要就可以判断是否值得读/是否是自己想要的。只读摘要不可，但摘要可以给人第一印象，需要好好读这部分。&lt;/p&gt;

    &lt;p&gt;如何判断是否是自己想要的文章？摘要（abstract）+介绍（introduction）+图+表格就可以基本了解了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其次看introduction部分，这部分主要介绍哪些技术难点和问题所在，以及简述自己方法的原理，如果你在选题，那么这部分讲完现阶段使用的方法之后、介绍自己方法之前的那部分内容，往往就是需要你来做的内容啦​,​做不做得出来另说:slightly_smiling_face:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;proposal这部分是文章核心，也是&lt;strong&gt;读懂论文的难点&lt;/strong&gt;所在，如果这篇论文很重要，那么一定要吃透文章的大部分原理，包括公式，虽然啃论文很苦涩，但是啃透了就会有种豁然开朗的话感觉。&lt;/li&gt;
  &lt;li&gt;实验这部分主要看一下实验方法和用到的数据集之类就可以，归纳主流的&lt;strong&gt;实验方法&lt;/strong&gt;和&lt;strong&gt;指标&lt;/strong&gt;。这样可以自己做实验的时候有一个指导&lt;/li&gt;
  &lt;li&gt;Conclusion就不说了&lt;/li&gt;
  &lt;li&gt;参考文献这部分，可以利用这部分探索其他值得读的文章，读了很多篇之后，就会知道哪一篇是高引文章了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;：总的来说，书读百遍，其意自现这话是有道理的，论文不用读那么多遍，和自己课题最相近的5-6篇啃透，同领域的和经典的25-40篇理解，整个领域及跨学科的了解就够了。&lt;/p&gt;

&lt;h3 id=&quot;精读与略读&quot;&gt;精读与略读&lt;/h3&gt;

&lt;p&gt;上面说的一般是我精读文章的步骤，但是很多文章，比如对于自己课题不是强相关、没有直接帮助、不是很新的，可以略读，具体方法是&lt;strong&gt;省略上述3，4，5部分&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;论文笔记&quot;&gt;论文笔记&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一定一定一定要记笔记&lt;/strong&gt;，一篇好的论文读下来，要整理自己的思路、理解和想法，不然读了之后就会忘，一篇文章100分的营养，没有笔记可能只能吸取30分（当然我比较菜，记了笔记也不敢说能完全理解，但这绝对是一个好习惯），个人推荐电子笔记而不是直接在PDF做标注，这样能够时刻回顾、比较系统、可以构建自己的论文知识体系，并且放在博客网站上还能和别人讨论。&lt;/p&gt;

&lt;p&gt;记笔记&lt;strong&gt;不宜把全文翻译下来&lt;/strong&gt;，那样和重复造轮子没什么区别，连造轮子都算不上。不一定很多，但是要&lt;strong&gt;把自己的理解，读文章时的想法，遇到的难点记录下来&lt;/strong&gt;，这样才是有帮助的。论翻译，我是比不过Google和有道，也没必要做机器的活儿。&lt;/p&gt;

&lt;h2 id=&quot;如何加深理解&quot;&gt;如何加深理解&lt;/h2&gt;

&lt;p&gt;对论文中一些原理和公式理解不清，怎么都想不明白，完全正常，我读十篇论文九篇不明白的，那么怎么加深理解（弄明白）？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PPT是个好东西&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;好处&lt;/strong&gt;：PPT更多使用描述性语言，生动的例子和图片，更能深入浅出（不带公式）地描述清楚原理。并且由于是作者自己做的，原汁原味，不会跑偏。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;适用&lt;/strong&gt;：非常知名、高影响力的工作。很多工作是不会做PPT/做了也不大会公开，不好搜索&lt;/p&gt;

    &lt;p&gt;比如Fastern RCNN，直接搜索论文名称+PPT/slide就大概率可以得到了：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JinluZhang1126/PublicPic/master/Pic/image-20200328171319497.png&quot; alt=&quot;image-20200328171319497&quot; style=&quot;zoom: 60%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;博客是个好东西&lt;/p&gt;

    &lt;p&gt;首推作者本人的博客，上面可能有对论文更深的解释&lt;/p&gt;

    &lt;p&gt;其次中国的CSDN，掘金，知乎，国外的reddit,medium以及github issues等，不一一列举，有更好网站的同学请补充给我&lt;/p&gt;

    &lt;p&gt;后者社区型博客好就好在足够多的用户可以进行评论、交流&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开源项目是个好东西&lt;/p&gt;

    &lt;p&gt;如果论文开源了，啥也不说，先跑通代码试试，说不定通过实验就理解了呢。有问题也可以通过github issues交流&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;论文作者是个好&lt;del&gt;东西&lt;/del&gt;人&lt;/p&gt;

    &lt;p&gt;大部分作者还是愿意分享自己的想法和成果的，毕竟都需要扩大工作的影响力，所以真不理解了/要源码/数据集，可以直接邮件，但不开源的要源码这事儿就看脸了，我是没成功过。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;脑子是个好东西&lt;/p&gt;

    &lt;p&gt;所有的方法归根到底，还是要靠自己，科研工作一定要有一个能&lt;strong&gt;独立思考&lt;/strong&gt;的脑子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;祝大家人人有顶会，年年有顶刊！&lt;/p&gt;

&lt;p&gt;欢迎交流&lt;/p&gt;</content><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><category term="how_to_research" /><summary type="html"></summary></entry><entry><title type="html">WIN10【Tensorflow-gpu+Anaconda3+cuda9.0+cudnn7.1】安装记录!</title><link href="http://localhost:4000/2020/03/11/tensorflow1.x-gpu-setup-in-win10.html" rel="alternate" type="text/html" title="WIN10【Tensorflow-gpu+Anaconda3+cuda9.0+cudnn7.1】安装记录!" /><published>2020-03-11T00:00:00+08:00</published><updated>2020-03-11T00:00:00+08:00</updated><id>http://localhost:4000/2020/03/11/tensorflow1.x-gpu-setup-in-win10</id><content type="html" xml:base="http://localhost:4000/2020/03/11/tensorflow1.x-gpu-setup-in-win10.html">&lt;p&gt;首先，版本问题一定要适配https://www.tensorflow.org/install/source_windows，我装的是tensorflow-gpu1.11.0，配套是
&lt;!--more--&gt;
&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image001-1575469940025.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CUDA&lt;/strong&gt;和&lt;strong&gt;CuDNN&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CUDA是NVIDIA推出的运算平台，CuDNN是专门针对Deep Learning框架设计的一套GPU计算加速方案。在安装之前要查询下最新TensorFLow发行版支持到了哪个版本。&lt;/p&gt;

&lt;p&gt;1）显卡型号支持：https://developer.nvidia.com/cuda-gpus&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image002-1575469940025.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）CUDA下载地址：https://developer.nvidia.com/cuda-toolkit-archive&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image003-1575469940026.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）CuDNN下载地址：https://developer.nvidia.com/rdp/cudnn-download&lt;/p&gt;

&lt;p&gt;（下载CuDNN需要注册账号，注册过程比较简单）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image004-1575469940026.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TensorFlow&lt;/p&gt;

&lt;p&gt;TensorFlow的版本信息可以在Github，tensorflow中文社区以及pypi上查看。&lt;/p&gt;

&lt;p&gt;Github：https://github.com/tensorflow/tensorflow/releases&lt;/p&gt;

&lt;p&gt;tensorflow社区：https://tensorflow.google.cn/versions/&lt;/p&gt;

&lt;p&gt;pypi：https://pypi.org/project/tensorflow/#history&lt;/p&gt;

&lt;p&gt;TensorFlow可以直接在Anaconda Prompt的命令行中用指令：“conda install tensorflow-gpu”直接安装，并且该指令在安装TensorFlow时还会顺带把Cuda和CuDNN也给装了。考虑到conda 的软件包并没有官方支持，并且tensorflow和附带的Cuda和CuDNN版本都不是最新的，笔者未使用conda安装，而是使用原生的 pip 安装，安装过程见后文。&lt;/p&gt;

&lt;h2 id=&quot;第一步安装anaconda&quot;&gt;&lt;strong&gt;第一步：安装Anaconda&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;下载和安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下载地址：https://www.anaconda.com/download/&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image005-1575469940026.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我系统是64位，所以下载 &lt;a href=&quot;https://repo.anaconda.com/archive/Anaconda3-5.2.0-Windows-x86_64.exe&quot;&gt;64-Bit Graphical Installer (631 MB)&lt;/a&gt;，之后就是进行安装了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image006-1575469940026.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和安装其他软件没有什么区别，需要注意的是这一步，不要勾选**“Add Anaconda to my PATH enviroment variable”，我们后面会手动加入。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image007-1575469940026.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来就是等待了，安装结束后需要测试是否能正常使用，打开CMD输入“conda”命令，发现提示“’conda’ is not recognized as an internal or external command, operable program or batch file.”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image008-1575469940026.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是由于我们没有配置环境变量的原因。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;strong&gt;Anaconda&lt;/strong&gt;&lt;strong&gt;环境变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们点击左下角搜索栏搜索“环境变量”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image009-1575469940026.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击环境变量&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image010.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择“Path”，点击“编辑”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image011.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将以下三个路径加入，注意这里要换成你自己的安装路径。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;G:\Anaconda\Anoconda3&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;G:\Anaconda\Anoconda3\Scripts&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;G:\Anaconda\Anoconda3\Library\bin&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;G:\Anaconda\Anoconda3\Library\mingw-w64\bin&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image012.png&quot; alt=&quot;G:\Anaconda\Anoconda3\Scripts &quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后点击“确定”保存，这回再测试一下，再cmd中输入“conda -V”，能正常显示版本号，证明已经配置好了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image013.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;来自 &amp;lt;&lt;a href=&quot;https://www.cnblogs.com/guoyaohua/p/9265268.html#第一步安装anaconda&quot;&gt;https://www.cnblogs.com/guoyaohua/p/9265268.html#%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%AE%89%E8%A3%85anaconda&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;h2 id=&quot;第二步安装tensorflow-gpu&quot;&gt;&lt;strong&gt;第二步：安装&lt;/strong&gt;&lt;strong&gt;TensorFlow-GPU&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;打开tensorflow官网：https://www.tensorflow.org/install/install_windows#installing_with_anaconda&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image014.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;跟着操作步骤走就可以了。&lt;/p&gt;

&lt;h3 id=&quot;1创建conda环境&quot;&gt;&lt;strong&gt;1.创建conda环境&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;通过调用下列命令，创建一个名为tfgpu的Conda环境：&lt;/p&gt;

&lt;p&gt;conda create -n tfgpu pip python=3.6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image015.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;等待相应包的安装，如果国内网络太慢的话，可以为conda设置清华源，这样速度能快一点，具体配置过程，网上查一下吧，此处不再讲述。如果看到这样的提示，就证明conda环境创建成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image016.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2激活环境&quot;&gt;&lt;strong&gt;2.&lt;/strong&gt;激活环境&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;通过以下命令激活&lt;/strong&gt;&lt;strong&gt;conda&lt;/strong&gt;&lt;strong&gt;环境：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;activate tensorflow&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image017.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就进入了刚创建的“tensorflow”环境。&lt;/p&gt;

&lt;h3 id=&quot;3安装tensorflow-gpu&quot;&gt;&lt;strong&gt;3.&lt;/strong&gt;安装tensorflow-gpu&lt;/h3&gt;

&lt;p&gt;安装GPU版本的tensorflow需要输入以下命令：&lt;/p&gt;

&lt;p&gt;pip install –ignore-installed –upgrade tensorflow-gpu&lt;/p&gt;

&lt;p&gt;如果只需要安装CPU版本的tensorflow则输入以下命令：&lt;/p&gt;

&lt;p&gt;pip install –ignore-installed –upgrade tensorflow&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image018.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就安装成功了。&lt;/p&gt;

&lt;p&gt;注意：务必注意一点，在安装完&lt;strong&gt;tensroflow后，由于我们是新创建的conda环境，该环境中基本上是空的，有很多包和IDE并没有安装进来，例如“Ipython”，“spyder”此时如果我们在该环境下打开spyder/Ipyton/jupyter notebook等，会发现其实IDE使用的kernel并不是新建立的这个环境的kernel，而是“base”这个环境的，而“base”环境中我们并没有安装tensorflow，所以一定无法import。这也就是为什么有很多人在安装好tensorflow后仍然在IDE里无法正常使用的原因了。&lt;/strong&gt;**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过以下命令安装&lt;/strong&gt;Anaconda基础包&lt;/p&gt;

&lt;p&gt;conda install anaconda&lt;/p&gt;

&lt;p&gt;这回，我们测试一下是否能import tensorflow&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image019.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;程序报错，这是由于我们虽然安装好了tensorflow-gpu，但是还需要安装CUDA Toolkit 和 cuDNN。&lt;/p&gt;

&lt;h2 id=&quot;第三步安装cuda-toolkit--cudnn&quot;&gt;&lt;strong&gt;第三步：安装&lt;/strong&gt;CUDA Toolkit + cuDNN&lt;/h2&gt;

&lt;h3 id=&quot;1查看需要安装的cudacudnn版本&quot;&gt;&lt;strong&gt;1.&lt;/strong&gt;查看需要安装的CUDA+cuDNN版本&lt;/h3&gt;

&lt;p&gt;注意，tensorflow是在持续更新的，具体安装的CUDA和cuDNN版本需要去官网查看，要与最新版本的tensorflow匹配。&lt;/p&gt;

&lt;p&gt;点击查看最新tensorflow支持的CUDA版本：https://www.tensorflow.org/install/install_windows#requirements_to_run_tensorflow_with_gpu_support&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image020.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在（PS：此博客书写日期 2018年7月5日）最新版tensorflow支持的是 CUDA® Toolkit 9.0 + cuDNN v7.0，一定注意，安装的版本一定一定要正确，不要看NVIDIA官网推出CUDA® Toolkit 9.2了就感觉最新版的更好，而安装最新版，这样很可能会导致tensorflow无法正常使用，所以一定要跟着tensorflow 官网的提示来。&lt;/p&gt;

&lt;h3 id=&quot;2下载cuda--cudnn&quot;&gt;&lt;strong&gt;2.&lt;/strong&gt;下载CUDA + cuDNN&lt;/h3&gt;

&lt;p&gt;在这个网址查找CUDA已发布版本：https://developer.nvidia.com/cuda-toolkit-archive&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image021.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入下载界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image022.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载好CUDA Toolkit 9.0 后，我们开始下载cuDnn 7.0，需要注意的是，下载cuDNN需要在nvidia上注册账号，使用邮箱注册就可以，免费的。登陆账号后才能下载。&lt;/p&gt;

&lt;p&gt;cuDNN历史版本在该网址下载：https://developer.nvidia.com/rdp/cudnn-archive&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image023.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image024.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样，我们就下载好了 CUDA Toolkit 9.0 和 cuDnn 7.0，下面我们开始安装。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image025.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3安装-cuda-toolkit-90-和-cudnn-70&quot;&gt;&lt;strong&gt;3.&lt;/strong&gt;安装 CUDA Toolkit 9.0 和 cuDnn 7.0&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;至关重要的一步：卸载显卡驱动&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于CUDA Toolkit需要在指定版本显卡驱动环境下才能正常使用的，所以如果我们已经安装了nvidia显卡驱动（很显然，大部分人都安装了），再安装CUDA Toolkit时，会因二者版本不兼容而导致CUDA无法正常使用，这也就是很多人安装失败的原因。而CUDA Toolkit安装包中自带与之匹配的显卡驱动，所以务必要删除电脑先前的显卡驱动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image026.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image027.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此处选择“自定义（高级）”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image028.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;勾选所有&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image029.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一路通过即可。&lt;/p&gt;

&lt;p&gt;接下来，解压“cudnn-9.0-windows10-x64-v7.zip”，将一下三个文件夹，拷贝到CUDA安装的根目录下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image030.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样CUDA Toolkit 9.0 和 cuDnn 7.0就已经安装了，下面要进行环境变量的配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置环境变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将下面四个路径加入到环境变量中，注意要换成自己的安装路径。(此处最好放到anaconda环境变量下面)&lt;/p&gt;

&lt;p&gt;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\bin&lt;/p&gt;

&lt;p&gt;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\libnvvp&lt;/p&gt;

&lt;p&gt;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0&lt;/p&gt;

&lt;p&gt;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\lib\x64&lt;/p&gt;

&lt;p&gt;到此，全部的安装步骤都已经完成，这回我们测试一下。&lt;/p&gt;

&lt;p&gt;安装完成后，打开cmd窗口，输入nvcc -V，查看CUDA是否正确安装。若正确安装，会出来下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;file:///C:/Users/KIMZHA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image031.png&quot; alt=&quot;da compl ler driver  nvcc :  Copyright (https://jinluzhang.site/PublicPic/Pic/clip_image031.png) 2005—2017 WIDIA Corporation  Built on Fri_Sep_1 21:08:32_Centra1_Day1ight_Time_2017  Cuda compi lation tools, release 9. 0, V9. 0. 176 &quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四步：测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.查看是否使用GPU&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import tensorflow as tf
tf.test.gpu_device_name()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image032.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.查看在使用哪个GPU&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from tensorflow.python.client import device_lib
device_lib.list_local_devices()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/clip_image033.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好了大功告成！&lt;/p&gt;

&lt;p&gt;https://www.cnblogs.com/guoyaohua/p/9265268.html&lt;/p&gt;</content><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><category term="configuration" /><summary type="html">首先，版本问题一定要适配https://www.tensorflow.org/install/source_windows，我装的是tensorflow-gpu1.11.0，配套是</summary></entry><entry><title type="html">Jekyll+云服务器搭建</title><link href="http://localhost:4000/2020/02/28/Jekyll-blog.html" rel="alternate" type="text/html" title="Jekyll+云服务器搭建" /><published>2020-02-28T00:00:00+08:00</published><updated>2020-02-28T00:00:00+08:00</updated><id>http://localhost:4000/2020/02/28/Jekyll-blog</id><content type="html" xml:base="http://localhost:4000/2020/02/28/Jekyll-blog.html">&lt;p&gt;&lt;em&gt;博客参考自：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;https://cloud.tencent.com/developer/article/1453573， https://segmentfault.com/a/1190000012560959&lt;/p&gt;

&lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;

&lt;p&gt;最近因为一些原因需要在自己租的云服务器上搭建Jekyll博客，&lt;!--more--&gt;由于之前都是在GitHub Pages上搭建的，其实在服务器这一块只需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git push&lt;/code&gt;上去就行了，现在多了一步如何在服务器上启动jekyll，因为看不少教程都没有说清楚这一步，所以写个博客记录一下，顺便梳理一下自己搭建博客的历程。&lt;/p&gt;

&lt;p&gt;下面以Jekyll模板+阿里云轻量服务器CentOS7.3为例，进行说明&lt;/p&gt;

&lt;h2 id=&quot;jekyllgithub-pages&quot;&gt;Jekyll+Github Pages&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;需要了解一下Jekyll的基础知识：http://jekyllcn.com/docs/home/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后需要建立一个你的仓库，命名为username.github.io即可，然后开启Github Pages功能，如图：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200225144538660.png&quot; alt=&quot;img-github-page&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;选一个喜欢的Jekyll模板，GitHub提供了几个，点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Change theme&lt;/code&gt;即可看到，觉得不喜欢还可以自己去找：http://jekyllthemes.org/， 选中之后去他的github仓库，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone&lt;/code&gt;下来，放进自己刚才创建的仓库，第一次搭建建议找一个README文档说明详细的，方便修改博客的各种属性，我选择的是&lt;a href=&quot;https://github.com/kitian616/jekyll-TeXt-theme&quot;&gt;Text Theme&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;本地调试需要搭建一个Ruby+bundle+jekyll的环境，参考http://jekyllcn.com/docs/installation/，对于ubuntu/centos用户，使用apt/yum等包管理安装的ruby版本可能不对，参考这里安装rubyhttps://segmentfault.com/a/1190000012560959&lt;/li&gt;
  &lt;li&gt;配置好之后，在博客文件夹下使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bundle exec jekyll serve&lt;/code&gt;即可在本地浏览器调试、预览。&lt;/li&gt;
  &lt;li&gt;先读模板的代码，对应修改一些属性，这是我修改之后的模板&lt;a href=&quot;https://github.com/JinluZhang1126/jinluzhang1126.github.io/tree/template&quot;&gt;Jinlu Zhang&lt;/a&gt;，对一些不明确的属性加了注释，然后还对模板根据喜好做了些修改，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone&lt;/code&gt;我这个也可以。&lt;/li&gt;
  &lt;li&gt;最终把自己满意的版本push到github仓库，他就可以自己部署了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;云服务器部署&quot;&gt;云服务器部署&lt;/h2&gt;

&lt;h3 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h3&gt;

&lt;p&gt;在云服务器上部署其实和本地调试区别不大，主要在于ruby版本和后续安装要正确，安装姿势也要对，&lt;strong&gt;切记不要直接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo yum install ruby&lt;/code&gt;,安装版本可能太老&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;（&lt;strong&gt;推荐&lt;/strong&gt;）rvm安装&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;源码编译：https://www.ruby-lang.org/en/documentation/installation/#building-from-source&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以使用rvm配置为例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装rvm&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gpg &lt;span class=&quot;nt&quot;&gt;--keyserver&lt;/span&gt; hkp://keys.gnupg.net &lt;span class=&quot;nt&quot;&gt;--recv-keys&lt;/span&gt; 409B6B1796C275462A1703113804BB82D39DC0E3
curl &lt;span class=&quot;nt&quot;&gt;-sSL&lt;/span&gt; https://get.rvm.io | bash &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; stable
   
&lt;span class=&quot;c&quot;&gt;# 如果上面的连接失败，可以尝试: &lt;/span&gt;
curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; stable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;可能会问你 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 管理员密码，以及自动通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Homebrew&lt;/code&gt; 安装依赖包，等待一段时间后就可以成功安装好 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RVM&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;然后，载入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RVM&lt;/code&gt; 环境（新开 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Termal&lt;/code&gt; 就不用这么做了，会自动重新载入的）&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /usr/local/rvm/scripts/rvm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;修改 RVM 的 Ruby 安装源到 Ruby China 的 Ruby 镜像服务器，这样能提高安装速度&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /usr/local/rvm/user/db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;检查一下是否安装正确&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rvm &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
   
rvm 1.29.3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;latest&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; by Michal Papis, Piotr Kuczynski, Wayne E. Seguin &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;https://rvm.io]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用rvm安装ruby&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rvm requirements
rvm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;2.7.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;设置 Ruby 版本,同样，也可以用其他版本号，前提是你有用 rvm install 安装过那个版本&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rvm use 2.7.0 &lt;span class=&quot;nt&quot;&gt;--default&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;测试&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruby &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
ruby 2.3.0p0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2015-12-25 revision 53290&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;x86_64-linux]
   
gem &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
2.5.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装bundler&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;bundler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;转到服务器上存放博客的路径下，启动jekyll服务&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;jekyll&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;serve&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这样启动的服务在你关闭命令行后就会停止，而我们在服务器的服务不可能保存命令行连接，因此需要修改为：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll serve &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; 0.0.0.0 &lt;span class=&quot;nt&quot;&gt;-P&lt;/span&gt; 80 &lt;span class=&quot;nt&quot;&gt;--detach&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;当你想要停止服务时，可以使用以下命令：&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;pkill&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jekyll&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;或者&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ps &lt;span class=&quot;nt&quot;&gt;-ef&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;jekyll
   
&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-9&lt;/span&gt; jekyll服务进程编号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;nginx端口分发&quot;&gt;nginx端口分发&lt;/h3&gt;

&lt;p&gt;服务器上不可能只运行一个博客，但是80端口只有一个&lt;/p&gt;

&lt;p&gt;在启动Jekyll服务时，使用的命令：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;jekyll&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;serve&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;detach&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中-P指定的就是启动时的端口，你可以修改为任意你服务器开放了的端口，如：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;jekyll&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;serve&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8899&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;detach&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，你就将Jekyll服务启动在了8899端口下，那么问题来了，刚才说的只能访问80端口呢！不急。&lt;/p&gt;

&lt;p&gt;我们在购买域名后，可以设置子域名。&lt;/p&gt;

&lt;p&gt;1.首先去域名购买网站的控制台，在解析记录中，添加你想使用的子域名,同样解析指向你的服务器，如：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;blog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;yuming&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;com&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.在服务器上安装nginx。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;$sudo&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;apt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nginx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.启动nginx&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;$sudo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nginx&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.修改nginx配置文件&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nginx&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;conf&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 http 后的大括号内添加图片内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200228103323218.png&quot; alt=&quot;image-20200228103323218&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;p&gt;liston：80。想要监听的端口 server_name:blog.yuming.com。为你设置的子域名 location 后面的 http://localhost:8899。为你启动的Jekyll端口。&lt;/p&gt;

&lt;p&gt;5.重新nginx&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nginx&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;restart&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后在浏览器访问你的子域名即可跳转至你的博客。&lt;/p&gt;</content><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><category term="configuration" /><summary type="html">博客参考自： https://cloud.tencent.com/developer/article/1453573， https://segmentfault.com/a/1190000012560959 需求 最近因为一些原因需要在自己租的云服务器上搭建Jekyll博客，</summary></entry><entry><title type="html">问题解决：Github图片无法访问</title><link href="http://localhost:4000/2020/02/25/github-img-not-available.html" rel="alternate" type="text/html" title="问题解决：Github图片无法访问" /><published>2020-02-25T00:00:00+08:00</published><updated>2020-02-25T00:00:00+08:00</updated><id>http://localhost:4000/2020/02/25/github-img-not-available</id><content type="html" xml:base="http://localhost:4000/2020/02/25/github-img-not-available.html">&lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;

&lt;p&gt;最近发现在墙内无法顺畅的访问github远程仓库中的图片，导致自己的博客中的图片全都裂开了。。。
&lt;!--more--&gt;
之前的访问方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找到github远程库中的图片，复制图片链接，格式一般是这样的：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://raw.githubusercontent.com/username/repo_name/img_name...&lt;/code&gt;，&lt;/li&gt;
  &lt;li&gt;在markdown文档中嵌入图片链接&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在的情况是这样的:cry:：&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200225115717536.png&quot; alt=&quot;image-20200225115717536&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;原因分析&quot;&gt;原因分析&lt;/h2&gt;

&lt;p&gt;github的服务器是在国外的，对于一些文字代码信息还可以预览编辑，但是图片却无法在线访问，如果切换到外网是可以访问的非常丝滑的，那么基本就是防火墙的问题了。但是博客对其他访问者是开放的，总不能让所有人都去翻翻翻。。。&lt;/p&gt;

&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;经过上下求索，找到了一个可靠长久的解决方法，特别是针对那些有写博客需求的人。&lt;/p&gt;

&lt;p&gt;我们需要给网站配置一个分流配置，具体原理不赘述，我的理解也不深，大致就是加了一个分流中转，让访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://raw.githubusercontent.com/username/repo_name/img_name...&lt;/code&gt;这个地址的人先访问国内的域名，然后通过DNS转到这个真实的地址&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;建立一个GitHub图片库，注意要设置为共有，以后图片都放到这里面&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200225121128297.png&quot; alt=&quot;image-20200225121128297&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;开启github pages功能，branch选中 master 就行&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200225144538660.png&quot; alt=&quot;image-20200225144538660&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;图中因为我配了一个域名，所以直接显示了域名，如果没有自己的域名就是github.io&lt;/li&gt;
  &lt;li&gt;直接访问域名+图片路径，以http://jinluzhang.site/PublicPic/Pic/image-20200225121128297.png为例，就会显示了，在markdown嵌入即可。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><category term="configuration" /><category term="bug" /><summary type="html">需求 最近发现在墙内无法顺畅的访问github远程仓库中的图片，导致自己的博客中的图片全都裂开了。。。</summary></entry><entry><title type="html">【论文笔记】SSD Single Shot MultiBox Detector</title><link href="http://localhost:4000/2020/02/22/SSD-Single-Shot-MultiBox-Detector.html" rel="alternate" type="text/html" title="【论文笔记】SSD Single Shot MultiBox Detector" /><published>2020-02-22T00:00:00+08:00</published><updated>2020-02-22T00:00:00+08:00</updated><id>http://localhost:4000/2020/02/22/SSD-Single-Shot-MultiBox-Detector</id><content type="html" xml:base="http://localhost:4000/2020/02/22/SSD-Single-Shot-MultiBox-Detector.html">&lt;blockquote&gt;
  &lt;p&gt;目标检测中的一个经典one-stage算法——SSD，ECCV2016中Wei Liu提出的，相比于YOLO针对于小目标检测更友好。文章基本按照论文行文思路和结构记笔记，最后给出一个sumary&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://link.springer.com/chapter/10.1007%2F978-3-319-46448-0_2&quot;&gt;论文地址&lt;/a&gt;  &lt;a href=&quot;https://github.com/balancap/SSD-Tensorflow&quot;&gt;代码地址&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;参考：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/58713034&quot;&gt;SSD论文笔记&lt;/a&gt;,&lt;/p&gt;

  &lt;!--more--&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;本文提出了一种使用单个深度神经网络来检测图像中的目标的方法，便于训练与优化，同时提高检测速度。&lt;strong&gt;将边界框的输出空间离散化为不同长宽比的一组default box，这些box是通过不同尺寸（分辨率）layer上的feature map得出的，每一层都具有不同的aspect ratios and scales&lt;/strong&gt;。在预测阶段，网络会在每个默认框中分别为每个类别生成分数，并对default box进行微调以更好地匹配目标形状。此外，网络还结合了&lt;strong&gt;不同分辨率的多个特征映射&lt;/strong&gt;的预测，自然地处理各种尺寸的目标。相对于region proposal的方法，SSD非常简单，因为它完全消除了提出生成和随后的像素或特征重采样阶段，并&lt;strong&gt;将所有计算封装到单个网络&lt;/strong&gt;中。&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;目前主流的目标检测算法分为两种，一种R-CNN流，主要思路是先使用选择性搜索之类的启发式方法（Selective Search）或CNN网络（RPN）生成region proposal，然后在此proposal上生成特征输入到分类和定位网络中，这类方法是&lt;strong&gt;two-stage&lt;/strong&gt;的，特点是精度高、速度略慢、训练较复杂；第二种是YOLO为代表的&lt;strong&gt;one-stage&lt;/strong&gt;流，它们的思路是均匀地在图片的不同位置进行密集抽样，抽样时可以采用不同的尺度和长宽比，然后利用CNN提取特征后直接进行分类和回归，整个过程只需要一步，所以它们的优势是速度快。但是均匀的密集采样有一个缺点就是正样本和负样本分布极不均衡，这会导致训练困难，导致模型准确度稍低。&lt;strong&gt;（可以通过FocalLoss缓解这个问题）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于改进了backbone网络，并且使用了不同分辨率的feature map，所以相比于YOLO流更加准确，尤其是对小物体检测敏感，速度也比faster rcnn更快。SSD属于one-stage，所以本文主要比较的也是YOLO流。&lt;/p&gt;

&lt;p&gt;原文这段话感觉概括了SSD的有别于其他方法的主要思想：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Our improvements include using a small convolutional filter to predict object
categories and offsets in bounding box locations, using separate predictors (filters) for
different aspect ratio detections, and applying these filters to multiple feature maps from
the later stages of a network in order to perform detection at multiple scales&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用VGG这种小卷积核网络进行提取初始目标特征和偏移量，并且针对不同尺度的feature maps产生不同的filter，然后将这种filter应用于之后的detection阶段。&lt;/p&gt;

&lt;h2 id=&quot;the-single-shot-detector-ssd-网络结构&quot;&gt;The Single Shot Detector (SSD)-网络结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200209121221893.png&quot; alt=&quot;image-20200209121221893&quot; style=&quot;zoom:150%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;网络的输入是300 x 300，称为SSD300；除此之外还有输入为500 x 500的SSD500，它在SSD300的基础上又加了一层conv11_2用于检测。&lt;/p&gt;

&lt;p&gt;SSD将VGG-16的全连接层fc6和fc7转换成3 x 3的卷积层Conv6和1 x 1的卷积层Conv7，并将pool5从2 x 2 - s2转换成3 x 3 - s1。第一个用于检测的feature map是Conv4_3，由于位置靠前，为了避免与后面的检测层差异太大，所以在Conv4_3后面使用L2 normalization，即仅对每个像素点在channel维度上进行归一化。&lt;/p&gt;

&lt;p&gt;可以看出，相比于YOLO网络，SSD主要改进在于：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VGG16作为特征提取网络；&lt;/li&gt;
  &lt;li&gt;使用不同尺寸的feature map提取出来的不同尺寸和长宽比的default box进行检测和分类。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;模型关键点&quot;&gt;模型关键点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;多尺度feature map预测&lt;/strong&gt;，&lt;strong&gt;SSD网络中分为了6个stage，每个stage能学习到一个特征图，然后进行边框回归和分类&lt;/strong&gt;，这些层的尺寸&lt;strong&gt;逐渐减小&lt;/strong&gt;，并允许&lt;strong&gt;多尺度&lt;/strong&gt;的预测。在Conv4_3、Conv6、Conv7、Conv8_2、Conv9_2、Conv10_2、Pool 11的feature map上都会进行检测，入到后面的&lt;em&gt;detection per class&lt;/em&gt;层， 提取出来类别概率和坐标：（c, x, y, w, h）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VGG网络作为特征提取网络&lt;/strong&gt;，去除最后两层FC层，改为3 x 3的卷积层Conv6和1 x 1的卷积层Conv7，并在之后增加尺寸依次减小的4个卷积层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用CNN检测&lt;/strong&gt;，这一部分和Faster RCNN中的RPN网络有些类似，对于feature map先使用3 x 3卷积，卷积后的结果代表feature map上每个像素代表的default box的信息，如类别概率或位置信息。&lt;/p&gt;

    &lt;p&gt;对于边框回归，只需要&lt;strong&gt;4维向量&lt;/strong&gt;即可，分别代表边框缩放尺度(坐标轴两个方向)和平移向量(坐标轴两个方向)。对于分类，SSD网络采取为每个类别进行打分的策略，也就是说对于每个Default Box，SSD网络会计算出相应的&lt;strong&gt;每个类别的分数&lt;/strong&gt;。假设数据集类别数为c，加上背景，那么总的类别数就是&lt;strong&gt;c+1&lt;/strong&gt;类。SSD网络采用了c+1维向量来分别代表该Default Box对于每个类别所得到的分数。这里，假设是VOC数据集，那么每个Default Box将生成一个20 + 1 + 4 = 25维的特征向量。同样，以Conv9输出特征图5x5为例。抽象地说特征向量就是：&lt;strong&gt;(m*n)*k*(c+4)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/MgVSAo8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Default boxes and aspect ratios&lt;/strong&gt;，feature map上每个像素都会生成多个default box。作者充分的吸取了Faster R-CNN中的Anchors机制，在每个Stage中根据Feature Map的大小，按照固定的Scale和Radio生成Default Boxes。这里为了方便阐述，选取了Conv9的Feature Map，输出大小为5x5。SSD网络中作者设置Conv9的每个点默认生成6个box，如下图所示。因此在这一层上，共生成了5x5x6=150个boxes。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/pToKpCA.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（👆这段解释来自👉&lt;a href=&quot;https://blog.csdn.net/neu_chenguangq/article/details/79057655&quot;&gt;here&lt;/a&gt;,感觉解释的很到位，特此说明）&lt;/p&gt;

&lt;p&gt;这样在不同尺度生成default box最大的好处在于可以对各种尺度和形状的物体进行预测：下图中狗的ground truth和4 x 4 feature map中default box匹配，但和8 x 8 feature map的任何一个default box都不匹配，所以SSD相对于RPN考虑更周到&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200222105802543.png&quot; alt=&quot;image-20200222105802543&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;注意区分dafault-box生成和cnn检测&quot;&gt;注意区分dafault box生成和CNN检测&lt;/h3&gt;

&lt;p&gt;这两个关键点是分开的，default box生成时对于feature map中每一个像素点生成4-6个不同长宽比的box，得到的是每一个cell的不同box&lt;/p&gt;

&lt;p&gt;而CNN检测是对每一个cell（也就是像素）进行3*3卷积，得到的是特征向量&lt;/p&gt;

&lt;p&gt;这两个我在一开始读论文的时候经常搞不清&lt;/p&gt;

&lt;h3 id=&quot;训练细节&quot;&gt;训练细节&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;如何选择default box的尺寸和长宽比&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;每层特征图上的尺度的default box计算表达式如下：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200209134820257.png&quot; alt=&quot;image-20200209134820257&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;参数：scale， aspect ratio——每个cell生成固定的scale（s）和aspect ratio（ar）的边界框&lt;/p&gt;

    &lt;p&gt;其中 Smin 为最小尺度0.2， Smax 为最大尺度0.95。&lt;/p&gt;

    &lt;p&gt;长宽比&lt;strong&gt;ar ∈ {1，2，3，1/2，1/3}&lt;/strong&gt;，&lt;/p&gt;

    &lt;p&gt;于是default box的宽和高可以通过 &lt;img src=&quot;https://www.zhihu.com/equation?tex=w_k%5Ea%3Ds_k%5Csqrt%7Ba_r%7D&quot; alt=&quot;[公式]&quot; /&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=h_k%5Ea%3Ds_k%2F%5Csqrt%7Ba_r%7D&quot; alt=&quot;[公式]&quot; /&gt; 计算，&lt;/p&gt;

    &lt;p&gt;除此之外，还增加一个长宽比为1的时候，尺度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_k%27%3D%5Csqrt%7Bs_ks_%7Bk%2B1%7D%7D&quot; alt=&quot;[公式]&quot; /&gt; 的default box，所以feature map上每个像素都有6个default box，&lt;strong&gt;注意这里得到的结果都是相对于原图的比例&lt;/strong&gt;。default box中心的坐标就是像素的中心。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;匹配策略&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;训练时需要建立ground truth和default box之间的对应关系，文中主要采用best jaccard overlap。与MultiBox稍有不同的是：SSD每个ground truth可以与多个default box匹配。&lt;/p&gt;

    &lt;p&gt;分为两步：首先对于每个ground truth，找到一个与其IoU最大的default box匹配，这个default box对应的预测框就作为正样本，其余都作为负样本。但这样做会导致负样本过多，正负样本分布极其不均衡，所以还会采取第二步：对于每个ground truth，将与其IoU大于某一阈值（比如0.5）的default box都进行匹配。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200222113304807.png&quot; alt=&quot;image-20200222113304807&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200222113449881.png&quot; alt=&quot;image-20200222113449881&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200222113710154.png&quot; alt=&quot;image-20200222113710154&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;[公式]&quot; /&gt; 为匹配成功的default box个数； &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha&quot; alt=&quot;[公式]&quot; /&gt; 是为了权衡两者损失而设置，通过交叉验证发现设置为1更好；第一项是置信度的Softmax损失，注意还包括背景这个类别；第二项是参数化后的bounding box中心坐标、长和宽的Smooth L1损失&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;难例挖掘&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用于预测的 feature map 上的每个点都对应有 6 个不同的 default box，绝大部分的 default box 都是负样本，导致了正负样本不平衡。在训练过程中，采用了 Hard Negative Mining 的策略（&lt;strong&gt;根据confidence loss对所有的box进行排序，使正负例的比例保持在1:3&lt;/strong&gt;） 来平衡正负样本的比率。这样做能提高4%左右。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数据增强&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;三个选项：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;使用整张图像作为输入&lt;/li&gt;
      &lt;li&gt;使用IOU和目标物体为0.1、0.3、0.5、0.7和0.9的patch，这些patch在原图的大小的[0.1, 1]之间，相应的宽高比在[1/2, 2]之间。&lt;/li&gt;
      &lt;li&gt;随机采取一个patch&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;experiment&quot;&gt;Experiment&lt;/h2&gt;

&lt;h3 id=&quot;caffe版本&quot;&gt;Caffe版本&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;System&lt;/th&gt;
      &lt;th&gt;VOC2007 test &lt;em&gt;mAP&lt;/em&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;FPS&lt;/strong&gt; (Titan X)&lt;/th&gt;
      &lt;th&gt;Number of Boxes&lt;/th&gt;
      &lt;th&gt;Input resolution&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ShaoqingRen/faster_rcnn&quot;&gt;Faster R-CNN (VGG16)&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;73.2&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;~6000&lt;/td&gt;
      &lt;td&gt;~1000 x 600&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;http://pjreddie.com/darknet/yolo/&quot;&gt;YOLO (customized)&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;63.4&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;98&lt;/td&gt;
      &lt;td&gt;448 x 448&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SSD300* (VGG16)&lt;/td&gt;
      &lt;td&gt;77.2&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;8732&lt;/td&gt;
      &lt;td&gt;300 x 300&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SSD512* (VGG16)&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;79.8&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;24564&lt;/td&gt;
      &lt;td&gt;512 x 512&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;tf版本代码&quot;&gt;TF版本（&lt;a href=&quot;https://github.com/balancap/SSD-Tensorflow&quot;&gt;代码&lt;/a&gt;）&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Model&lt;/th&gt;
      &lt;th&gt;Training data&lt;/th&gt;
      &lt;th&gt;Testing data&lt;/th&gt;
      &lt;th&gt;mAP&lt;/th&gt;
      &lt;th&gt;FPS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://drive.google.com/open?id=0B0qPCUZ-3YwWZlJaRTRRQWRFYXM&quot;&gt;SSD-300 VGG-based&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;VOC07+12 trainval&lt;/td&gt;
      &lt;td&gt;VOC07 test&lt;/td&gt;
      &lt;td&gt;0.778&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://drive.google.com/file/d/0B0qPCUZ-3YwWUXh4UHJrd1RDM3c/view?usp=sharing&quot;&gt;SSD-300 VGG-based&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;VOC07+12+COCO trainval&lt;/td&gt;
      &lt;td&gt;VOC07 test&lt;/td&gt;
      &lt;td&gt;0.817&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://drive.google.com/open?id=0B0qPCUZ-3YwWT1RCLVZNN3RTVEU&quot;&gt;SSD-512 VGG-based&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;VOC07+12+COCO trainval&lt;/td&gt;
      &lt;td&gt;VOC07 test&lt;/td&gt;
      &lt;td&gt;0.837&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;和YOLO一样不同类别之间共享回归器，所以易混淆相似的类别&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;对小物体的检测相对于YOLO好一点&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;比YOLOv1快且精准度高，比Faster R-CNN精度略低&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;SSD整个网络采取了one stage的思想，以此提高检测速度。并且网络中融入了Faster R-CNN中的anchors思想，并且做了特征分层提取并依次计算边框回归和分类操作。总之，这是一个延申RPN网络思想，同时又结合YOLO框架的方法。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><category term="paper" /><category term="detection" /><summary type="html">目标检测中的一个经典one-stage算法——SSD，ECCV2016中Wei Liu提出的，相比于YOLO针对于小目标检测更友好。文章基本按照论文行文思路和结构记笔记，最后给出一个sumary 论文地址 代码地址 参考：SSD论文笔记,</summary></entry><entry><title type="html">Ubuntu18.04重装Nvidia驱动，cuda和cudnn，多用户使用anaconda</title><link href="http://localhost:4000/2020/02/17/Ubuntu18.04-rebuild-Nvidia-driver-cuda-cudnn-multi-use-anaconda.html" rel="alternate" type="text/html" title="Ubuntu18.04重装Nvidia驱动，cuda和cudnn，多用户使用anaconda" /><published>2020-02-17T00:00:00+08:00</published><updated>2020-02-17T00:00:00+08:00</updated><id>http://localhost:4000/2020/02/17/Ubuntu18.04-rebuild-Nvidia-driver-cuda-cudnn-multi-use-anaconda</id><content type="html" xml:base="http://localhost:4000/2020/02/17/Ubuntu18.04-rebuild-Nvidia-driver-cuda-cudnn-multi-use-anaconda.html">&lt;p&gt;最近手残升级了nvidia显卡驱动，导致cuda与驱动冲动，没办法只能重装了。
&lt;!--more--&gt;
配置信息：&lt;br /&gt;系统：Ubuntu18.04；显卡：Nvidia 2080Ti；驱动：Nvidia Driver 440.44；cuda：10.2；cudnn：7.6.5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200108100525530.png&quot; alt=&quot;img&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看cuda 版本
cat /usr/local/cuda/version.txt&lt;/p&gt;

&lt;p&gt;查看cudnn 版本
cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200108100752066-1581941094214.png&quot; alt=&quot;image-20200108100752066&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;重装显卡驱动&quot;&gt;重装显卡驱动&lt;/h2&gt;

&lt;h3 id=&quot;禁用nouveau驱动&quot;&gt;禁用nouveau驱动&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo vim /etc/modprobe.d/blacklist.conf&lt;/code&gt;
在文本最后添加：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;blacklist nouveau
options nouveau modeset=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后执行：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo update-initramfs -u&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重启机器后，执行以下命令，如果没有屏幕输出，说明禁用nouveau成功：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsmod | grep nouveau&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;下载驱动&quot;&gt;下载驱动&lt;/h3&gt;

&lt;p&gt;官网下载地址：https://www.nvidia.cn/Download/index.aspx?lang=cn ，根据自己显卡的情况下载对应版本的显卡驱动。下载得到一个.run安装包，之后会用到。&lt;/p&gt;

&lt;h3 id=&quot;卸载旧驱动&quot;&gt;卸载旧驱动&lt;/h3&gt;

&lt;p&gt;重启后，使用快捷键进入文本模式，然后输入用户名密码就可：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl-Alt+F1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;执行以下命令禁用X-Window服务，否则无法安装显卡驱动：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo service lightdm stop&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;执行以下命令卸载原有显卡驱动：注意匹配自己下载的驱动版本&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get remove --purge nvidia*
sudo apt-get autoremove
sudo chmod +x NVIDIA-Linux-x86_64-4**.**.run
sudo ./NVIDIA-Linux-x86_64-4**.**.run --uninstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;安装新驱动&quot;&gt;安装新驱动&lt;/h3&gt;

&lt;p&gt;保险期间，再重启一遍。直接执行驱动文件即可安装新驱动，一直默认即可：&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ./NVIDIA-Linux-x86_64-410.93.run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行以下命令启动X-Window服务&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service lightdm start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后执行重启命令，重启系统即可：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;reboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;重装cuda&quot;&gt;重装CUDA&lt;/h2&gt;

&lt;p&gt;因为重装后的驱动和原来CUDA版本还是不一样（如果之前安装了CUDA，可以用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvcc -V&lt;/code&gt;试试，不行的话还是重装吧​🙂​）&lt;/p&gt;

&lt;p&gt;卸载CUDA执行的是CUDA自带的卸载脚本，读者要根据自己的cuda版本找到卸载脚本：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo /usr/local/cuda-10.0/bin/uninstall_cuda_10.0.pl&lt;/code&gt;
卸载之后，还有一些残留的文件夹，之前安装的是CUDA 8.0。可以一并删除：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo rm -rf /usr/local/cuda-10.0/&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;安装cuda&quot;&gt;安装CUDA&lt;/h2&gt;

&lt;h3 id=&quot;下载安装&quot;&gt;下载安装&lt;/h3&gt;

&lt;p&gt;在官网：&lt;a href=&quot;https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;amp;target_arch=x86_64&amp;amp;target_distro=Ubuntu&amp;amp;target_version=1604&amp;amp;target_type=runfilelocal&quot;&gt;CUDA下载页面&lt;/a&gt;，下载符合自己系统版本的CUDA。&lt;/p&gt;

&lt;p&gt;下载完成之后，给文件赋予执行权限：&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod +x cuda_*****_linux.run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行安装包，开始安装：&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./cuda_****_linux.run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CUDA10.2安装时会显示这样一个画面👇，不安装驱动了，注意把Driver去掉，否则会导致重复安装驱动&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jinluzhang.site/PublicPic/Pic/image-20200107223538310.png&quot; style=&quot;zoom: 80%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;配置环境变量&quot;&gt;配置环境变量&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export CUDA_HOME=/usr/local/cuda-10.2
export LD_LIBRARY_PATH=${CUDA_HOME}/lib64
export PATH=${CUDA_HOME}/bin:${PATH}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;安装cudnn&quot;&gt;安装CUDNN&lt;/h2&gt;

&lt;p&gt;CUDNN的下载官网：https://developer.nvidia.com/rdp/cudnn-download ，点击Download开始选择和CUDA10.2匹配的下载版本，选择&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cuDNN Library for Linux&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;对它进行解压，命令如下：&lt;/p&gt;

&lt;p&gt;tar -zxvf cudnn-10.0-linux-x64-v7.4.2.24.tgz&lt;/p&gt;

&lt;p&gt;解压之后可以得到以下文件：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;cuda/include/cudnn.h
cuda/NVIDIA_SLA_cuDNN_Support.txt
cuda/lib64/libcudnn.so
cuda/lib64/libcudnn.so.7
cuda/lib64/libcudnn.so.7.4.2
cuda/lib64/libcudnn_static.a&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用以下两条命令复制这些文件到CUDA目录下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp cuda/lib64/* /usr/local/cuda-10.0/lib64/
cp cuda/include/* /usr/local/cuda-10.0/include/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;拷贝完成之后，可以使用以下命令查看CUDNN的版本信息：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;安装anaconda3&quot;&gt;安装Anaconda3&lt;/h2&gt;

&lt;p&gt;先去官方地址下载好对应的安装包&lt;a href=&quot;https://www.anaconda.com/download/#linux&quot;&gt;Ubuntu - anaconda 下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后直接安装anaconda ：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bash ~/Downloads/Anaconda3-5.2.0-Linux-x86_64.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装过程中看到&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Welcome to Anaconda3 5.2.0
In order to continue the installation process, please review the license
agreement. (为了继续安装过程，请审核许可证。协议。)
Please, press ENTER to continue&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直接按enter查看协议，然后一直enter下去，&lt;/p&gt;

&lt;p&gt;然后看到&lt;/p&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;Do you accept the license terms? [yes&lt;/td&gt;
        &lt;td&gt;no]（你接受许可证条款吗?）&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;直接输入yes 然后按enter，进入下一步&lt;/p&gt;

&lt;p&gt;接下来会提示安装地址：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Anaconda3 will now be installed into this location:
/home/user/anaconda3&lt;/p&gt;

  &lt;p&gt;Press ENTER to confirm the location
Press CTRL-C to abort the installation
Or specify a different location below&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;建议默认即可，
按enter继续下一步，注意这里按ctrl + c 直接会终止安装。
接下来先等待安装即可。
看到&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thank you for installing Anaconda3!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;表示安装成功。&lt;/p&gt;

&lt;h3 id=&quot;添加环境变量&quot;&gt;添加环境变量&lt;/h3&gt;

&lt;p&gt;anaconda会自动将环境变量添加到PATH里面，如果后面你发现输出conda
提示没有该命令，那么你需要source ~/.bashrc 这样就是更新环境变量，就可以正常使用了。
如果发现这样还是没用，那么需要收到添加环境变量
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo vim ~/.basrc&lt;/code&gt; 文件，在最后面加上
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export PATH=/home/user/anaconda3/bin:$PATH&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;保存退出后：source ~/.bashrc
再次输入conda list测试看看，应该就是没有问题啦！&lt;/p&gt;

&lt;h2 id=&quot;多用户使用conda&quot;&gt;多用户使用conda&lt;/h2&gt;

&lt;p&gt;注意我在user用户下安装配置的conda，怎么在其他用户里使用conda呢？直接使用会报错没有conda命令&lt;/p&gt;

&lt;p&gt;做如下配置：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;su another_user
sudo vim ~/.basrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后一行加上conda安装位置的环境变量：export PATH=/home/user/anaconda3/bin:$PATH&lt;/p&gt;

&lt;p&gt;保存退出后：source ~/.bashrc&lt;/p&gt;

&lt;p&gt;如果使用conda activate命令显示没有初始化这样的错误，运行下面代码：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/anaconda3/etc/profile.d/conda.sh
conda activate my_env
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><category term="configuration" /><summary type="html">最近手残升级了nvidia显卡驱动，导致cuda与驱动冲动，没办法只能重装了。</summary></entry><entry><title type="html">Hello World!</title><link href="http://localhost:4000/2020/02/16/hello-world.html" rel="alternate" type="text/html" title="Hello World!" /><published>2020-02-16T00:00:00+08:00</published><updated>2020-02-16T00:00:00+08:00</updated><id>http://localhost:4000/2020/02/16/hello-world</id><content type="html" xml:base="http://localhost:4000/2020/02/16/hello-world.html">&lt;p&gt;Hi everyone, welcome come to my blog website.:wink:&lt;/p&gt;

&lt;p&gt;I start this blog website by myself and Powered by &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://github.com/kitian616/jekyll-TeXt-theme&quot;&gt;TeXt Theme&lt;/a&gt;. Thanks the &lt;a href=&quot;https://github.com/kitian616&quot;&gt;author&lt;/a&gt; of this theme.&lt;/p&gt;

&lt;p&gt;If you like my blog theme, Just take it away &lt;a href=&quot;https://github.com/JinluZhang1126/jinluzhang1126.github.io/tree/template&quot;&gt;here&lt;/a&gt;! It is yours now! :laughing:
&lt;!--more--&gt;
This blog is mainly for recording my &lt;strong&gt;research and learning life&lt;/strong&gt; in the future.&lt;/p&gt;

&lt;p&gt;I will try my best to write my blog with English, but you know, my English is not solid enough to express myself:pensive:. Thus i will firstly write logs with Chinese. If you want any article’s English version or have any qusetion, just comment to me in the comment area at each article’s footer.&lt;/p&gt;

&lt;p&gt;I am Jinlu Zhang. I am coming to a new world! :smiley:&lt;/p&gt;</content><author><name>Jinlu Zhang</name><email>Jinluzhang1126@163.com</email></author><summary type="html">Hi everyone, welcome come to my blog website.:wink: I start this blog website by myself and Powered by Jekyll &amp;amp; TeXt Theme. Thanks the author of this theme. If you like my blog theme, Just take it away here! It is yours now! :laughing:</summary></entry></feed>